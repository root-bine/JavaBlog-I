# 数据结构概述

## 1、<span style="color:brown">线性与非线性：</span>

**1.1、线性结构：**

> 线性结构作为**最常用的数据结构**
>
> 线性结构常见的有：数组、队列、链表和栈......

<u>数据元素之间存在**一对一的线性关系**</u>

- 顺序存储结构：
  - 顺序存储的线性表称为顺序表；
  - **顺序表中存储的元素是连续的**；
- 链式存储结构：
  - 链式存储的线性表称为链表；
  - **链表中的存储元素不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息

**1.2、非线性结构：**

非线性结构包括:二维数组，多维数组，广义表，树结构，图结构



## 2、<span style="color:brown">时间复杂度：</span>

### <!--做算法分析主要研究: 时间复杂度, 本质上还是空间换取时间--->

**2.1、时间频度/语句频度：**

> 一个算法<u>花费的时间与算法中语句的执行次数成正比例</u>，哪个算法中语句执行次数多，它花费时间就多

<span style="color:green">**一个算法中的语句执行次数**</span>，记为`T(n)`

**2.2、特点：**

随着n不断变大，时间频度的变化跟一下内容无关：

- 忽略常数项；
- 忽略低次项；
- 忽略高次项的系数；

**2.3、时间复杂度的计算：**

> 使用常数1代替，是由于常数的时间复杂度为：O(1)
>
> 若有某个辅助函数f(n)，使得n趋近于无穷大时，T(n)/f(n)的极限为不等于0的常数，记作: T(n) = O(f(n))

```scss
1. 用'常数1'代替运行时间中的所有加法常数
2. 修改后的运行次数函数中，只保留最高阶项
3. 去除最高阶项的系数
```

**2.4、常见的时间复杂度：**

> 以下顺序，**时间复杂度逐渐增加**，但<u>算法执行效率越来越低</u>

$$
常数阶O(1)、对数阶O(log_2 n)、

线性阶O(n)、线性对数阶O(nlog_2 n)、

平方阶O(n^2)、立方阶O(n^3)、k次方阶O(n^k)、

指数阶O(2^n)
$$

---

> 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长

|                        平均时间复杂度                        |                    最坏时间复杂度                     |
| :----------------------------------------------------------: | :---------------------------------------------------: |
| 所有可能的输入实例均以**等概率出现**的情况下，该算法的运行时间 | <u>一般讨论的时间复杂度均是最坏情况下的时间复杂度</u> |

**2.5、范例解析：**

![image-20221111143726047](https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%AF%B9%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89.png)

```java
int i = 1;
while(i<n){
    i = i*3
}
```

在while循环中，i每次乘以3，逐渐跟n的值接近。

当x次之后，i大于n，跳出while循环，记作：3^x = n，算法时间复杂度为：log_3 n

---

```java
for(i=0;i<n;i++){
    j=i;
    j++；
}
```

时间频度为：T(n)，算法时间复杂度：O(n)

---

```java
for(m=1;m<=n;m++){
    int i = 1;
	while(i<n){
   		i = i*3
	}
}
```

线性对数阶，相当于将时间复杂度为：O(log_2 n)的代码循环n遍，即：n*O(log_2 n)，也就是O(nlog_2 n)